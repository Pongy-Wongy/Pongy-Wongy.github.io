---
layout: single
title: "Springsecurity로 회원가입기능 구현"
excerpt: "SecurityConfig,CSRF,Lambda표현식,BCryptPasswordEncoder을 이용한 비번hasing,원래있던 라이브러리 사용히 @Configuration,@Bean을 이용한 DI(의존성주입) 을 배워보자"
categories: SpringBoot
tag: SpringBoot
toc: true
published: true
---

## Springsecurity란?
구글에 검색한 결과....
![Spring 이미지](/assets/images/spring12.png)
![Spring 이미지](/assets/images/spring121.png)

간단히 설명하면 Spring Security는 Spring기반의 앱의 보안(인증 및 권한, 인가 등)을 담당하는 스프링 라이브러리다.
그럼 인증은 뭐고 인가는 뭐냐?

### 인증 및 인가
인증(**Authentication**): 신원확인 절차
인가(**Authorization**): 인증된 사용자가 요청한 자원에 접근 가능한지를 결정
![Spring 이미지](/assets/images/spring122.png)

### 설치 후 localhost접속
그럼이제 라이브러리 설치도 했겠다 사이트에 접속해보자(http://localhost:8080/list)
![Spring 이미지](/assets/images/spring123.png)
list페이지로 접속을 하려했는데 **springscurity**로 인해 http://localhost:8080/login
으로 이동했다.  
로그인하는방법은 간단한데....id에 user 그리고 pw에
![Spring 이미지](/assets/images/spring124.png)
적어주면 로그인이 된다.
근데 중요한건 /list페이지 뿐만아니라 모든페이지를 로그인후 접속할 수 있게 **springscurity**가 막아놓고 있기때문에 이를 해제해야 한다.
어떻게 해제하지? 구글에 검색해보자.

## SecurityConfig
![Spring 이미지](/assets/images/spring125.png)
![Spring 이미지](/assets/images/spring126.png)

```java
package com.example.demo;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf((csrf) -> csrf.disable());
        http.authorizeHttpRequests((authorize) -> authorize.requestMatchers("/**").permitAll());
        return http.build();
    }
}
```
- FilterChain: 모든 유저의 요청과 서버의 응답사이에 자동으로 실행해주고 싶은 코딩하는 곳

- requestMatchers: requestMatchers를 사용하여 특정 경로의 접근을 제어할 수 있습니다. 

- 모든 사용자에게 허용: http.requestMatchers(" /public/**").permitAll() 

- 로그인한 사용자만 허용: http.requestMatchers(" /private/**").authenticated() 

그리고 위의 코드를 보면 **csrf**보안기능을 잠깐 off해놨는데 개발시에는 꺼두고 하는게 편리하다. 근데 **csrf**가 모임?

## CSRF(Cross-Site Request Forgery)

### CSRF공격
```markdown
CSRF(Cross-Site Request Forgery) 공격은 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격 방식입니다. 인증된 사용자의 권한을 악용해 공격을 실행하며, 정보 탈취가 아닌 사용자의 의도와 다른 작업을 강제로 수행하게 하는 것이 특징입니다. 
```
![Spring 이미지](/assets/images/spring127.png)

### CSRF방어
![Spring 이미지](/assets/images/spring128.png)

### Lambda Expression
```java
http.csrf((csrf) -> csrf.disable());
```
() -> {} 이런식으로 함수 빠르게 만들수 있음 
함수 하나를 만들때 parameter로 다른 함수를 넣어서 실행하게 만들 수 있다.  
언제사용하냐면
1. 뭔가 순차적으로 실행하게 만들고 싶거나
2. 내가 만든 함수에 다른 사람의 코드를 집어넣어서 실행하게 만들고 싶을때.

## 회원가입 기능 만들기
### 회원가입페이지 만들기
```html
<body>
    <form action="/user" method="POST">
        <input name="displayName" placeholder="이름">
        <input name="username" placeholder="아이디">
        <input name="password" type="password">
        <button type="submit">전송</button>
    </form>
</body>
```

### MemberController만들고 GET요청 API
```java
@Controller
public class MemberController {
     @GetMapping("/signup")
    String signUp() {
        return "signup.html";
    }
}
```

### Member테이블 만들기(@Entity)
```java
@Entity
@Getter
@Setter
@ToString
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private String username;
    private String displayName;
    private String password;

}
```

### Member테이블 데이터 입출력 및 등록(MemberRepository만들기)

- **MemberRepository만들기**

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
MemberRepository
}
```

- **MemberRepository을 @Controller에 등록**
```java
@Controller
@RequiredArgsConstructor
public class MemberController {

    private final MemberRepository memberRepository;

    @GetMapping("/signup")
    String signUp() {
        return "signup.html";
    }

    @PostMapping("/user")
    public String addMember(){
        (회원가입기능 API 코딩하는 곳)
        return "redirect:/list";
    }

}

```

- **회원가입정보 저장**
```java
@Controller
@RequiredArgsConstructor
public class MemberController {

    private final MemberRepository memberRepository;

    @GetMapping("/signup")
    String signUp() {
        return "signup.html";
    }

    @PostMapping("/user")
    public String addMember(
            @RequestParam("username") String username,
            @RequestParam("password") String password,
            @RequestParam("displayName") String displayName) {
        Member member = new Member();
        member.setUsername(username);
        var hash = new BCryptPasswordEncoder().encode(password);
        member.setPassword(hash);
        member.setDisplayName(displayName);
        memberRepository.save(member);

        return "redirect:/list";
    }

}
```
```java
var hash = new BCryptPasswordEncoder().encode(password);
```
이 코드 쓰면 비밀번호를 DB에 저장 할때 암호화해서 저장할 수 있는데 근데 이렇게
매번회원가입할때마다 object를 만들면서 쓰면 좀 별로임 저번에 배운대로
**DI(의존성주입)** 방식으로 쓰면 될 거 같음.
근데 **BCryptPasswordEncoder**이건 원래 만들어져 있는 class여서
만들어져 있는 class에 **DI(의존성주입)**하려면

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
**return으로 new함수()한다음 @Configuration,@Bean**
(Bean은 spring이 만든 object임)

이제 이 @Bean을 사용하려면 등록하면됨

```java
@Controller
@RequiredArgsConstructor
public class MemberController {
  private final PasswordEncoder passwordEncoder;

  //DI 이전코드
  //String hash = new BCryptPasswordEncoder().encode(password);

  //DI 이후코드
  String hash = passwordEncoder.encode(password);
}
```

## 최종코드

```java
@Controller
@RequiredArgsConstructor
public class MemberController {

    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    @GetMapping("/signup")
    String signUp() {
        return "signup.html";
    }

    @PostMapping("/user")
    public String addMember(
            @RequestParam("username") String username,
            @RequestParam("password") String password,
            @RequestParam("displayName") String displayName) {
        Member member = new Member();
        member.setUsername(username);
        String hash = passwordEncoder.encode(password);
        member.setPassword(hash);
        member.setDisplayName(displayName);
        memberRepository.save(member);

        return "redirect:/list";
    }

}
```
이제 http://localhost:8080/signup 회원가입페이지 접속해서 확인해보자
![Spring 이미지](/assets/images/spring129.png)
![Spring 이미지](/assets/images/spring1210.png)
DB에 회원정보가 잘 저장되었고 비밀번호는 **Hasing(암호화)**되서 저장된걸 확인 할 수 있다. 회원가입기능구현 끝!







