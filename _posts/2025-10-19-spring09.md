---
layout: single
title: "@Service 와 DI(의존성주입)"
excerpt: "비즈니스로직은 @Service로 분리하고, DI(의존성주입)에 대해 배워보자!!"
categories: SpringBoot
tag: SpringBoot
toc: true
published: true
---

```java
  @PostMapping("/product")
    String addProduct(@RequestParam String title, @RequestParam Integer price) {
        Product product = new Product();
        product.setTitle(title);
        product.setPrice(price);
        productRepository.save(product);
        return "redirect:/list";
    }
```
이 코드같은 경우에  2개의 기능이 같이있다.
1. DB데이터 입출력 기능
2. html로 return(list페이지 보여주는 기능)

근데 하나의 함수에는 한개의 기능만 있는게 좋다.
옷바구니에는 옷,과일바구니에는 과일만 있어야 찾기쉽지않나?
뒤죽박죽있으면 코드가 길어지면 햇갈린다.

1번같은 경우에는 비즈니스로직 @Service에 어울리고
2번은 @Controller에 어울린다.

그러면 1번기능을 ProductService를 만들어서 코드를 짜보자

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private ProductRepository productRepository;

    public void saveProduct(String title, Integer price) {
        Product product = new Product();
        product.setTitle(title);
        product.setPrice(price);
        productRepository.save(product);
    }
}
```

지금 하려는 것은 함수기능 분리니깐 ProductService에서
상품데이터저장함수인 saveProduct를 만들었다.
productRepository도 import해줬다.

자 이제 함수를 만들었으니깐 ProductService class를 복사해서
obeject를 만든다음 함수를 사용하면되는데 그럴려면
```java
ProductService productService = new ProductService()
```
이렇게 매번 object를 만들어서 써야한다 언제? POST요청이  
들어올때마다 그래야 된다. 메모리에 부담도 많이가고 많이 비 효율적이다.
그럼어떻게 하냐?

위쪽에 코드에서 @Service 어노테이션을 추가했는데 이를 이용하면 된다.
**@Service를 사용하면 다른 클래스에서 변수만 등록하면 사용가능!!**

```java
@Controller
@RequiredArgsConstructor
public class ProductController {

    private final ProductRepository productRepository;
    private final ProductService productService;

    @PostMapping("/product")
    String addProduct(@RequestParam String title, @RequestParam Integer price) {
        productService.saveProduct(title, price);
        return "redirect:/list";
    }
}
```

위처럼 **private final ProductService productService** 변수로 등록하면
굳이 매번 new키워드로 object를 만들지 않고도
- **productService.함수()** 
이런식으로 사용하면 끝!

## DI(Dependency injection:의존성주입)
근데 이렇게 코드를 짜는 방법을 **Dependency injection(의존성주입)** 이라고 부른다.

간단히 요약하면 productRepository,productService에  
new productRepository(), new productService()를 spring이 이미 만들어놨다.
그래서 우리는 그냥 가져다가 쓰면 되는거다. 좀더 자세히 설명을 하면........
이건 AI가 알려줄거임....
![Spring 이미지](/assets/images/spring09.png)
![Spring 이미지](/assets/images/spring091.png)

그렇다고 한다....근데 여기서 중요한건 생성자주입으로 적용하는데
Lombok문법 @RequiredArgsConstructor으로 생성자를 자동생성했다.
만약 이걸 사용하지않으면 코드가 좀 길어진다. 그래도 좀 알고가자

```java
@Controller
public class ProductController {
  private final ProductRepository productRepository;
  private final ProductService productService;

  @Autowired
  ProductController(ProductRepository ProductRepository, ProductService productService) {
   this.ProductRepository = ProductRepository;
   this.ProductService = ProductService;
  }

}
```

![Spring 이미지](/assets/images/spring092.png)

그럼여기서 빈(Bean) 컨테이너가 뭘까?

## Container,Bean이란?
Spring이 object를 뽑아서 보관하는 공간을 **Container**라 하고 
거기 안에 들어있는 object들을 **Spring의 Bean**이라고 부릅니다. 
![Spring 이미지](/assets/images/spring093.png)

## 결론 
1. 하나의 함수에는 하나의 기능만
2. 비즈니스로직은 @Service
3. **DI(의존성주입)의 중요성**
4. Container,Bean의 관계!